#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/rand.h>
#include <openssl/evp.h>

#define AES_KEY_SIZE 256
#define BUFFER_SIZE 1024

void handleErrors(void)
{
    perror("Error");
    exit(EXIT_FAILURE);
}

void generateAESKey(const char *filename)
{
    FILE *keyFile = fopen(filename, "wb");
    if (keyFile == NULL) {
        handleErrors();
    }

    unsigned char aes_key[AES_KEY_SIZE/8];
    if (!RAND_bytes(aes_key, sizeof(aes_key))) {
        handleErrors();
    }

    fwrite(aes_key, sizeof(unsigned char), sizeof(aes_key), keyFile);
    fclose(keyFile);
}

void encryptFile(const char *inputFilename, const char *outputFilename, const char *keyFilename){
    FILE *inputFile = fopen(inputFilename, "rb");
    FILE *outputFile = fopen(outputFilename, "wb");
    FILE *keyFile = fopen(keyFilename, "rb");

    if (inputFile == NULL || outputFile == NULL || keyFile == NULL) {
        handleErrors();
    }

    unsigned char aes_key[AES_KEY_SIZE/8];
    fread(aes_key, sizeof(unsigned char), AES_KEY_SIZE/8, keyFile);
    fclose(keyFile);

    EVP_CIPHER_CTX *ctx;
    int len;
    unsigned char plaintext[BUFFER_SIZE];
    unsigned char ciphertext[BUFFER_SIZE + EVP_MAX_BLOCK_LENGTH];

    ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        handleErrors();
    }

    EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, aes_key, NULL);

    while ((len = fread(plaintext, 1, BUFFER_SIZE, inputFile)) > 0) {
        if (EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, len) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            handleErrors();
        }
        fwrite(ciphertext, 1, len, outputFile);
    }

    if (EVP_EncryptFinal_ex(ctx, ciphertext, &len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        handleErrors();
    }

    fwrite(ciphertext, 1, len, outputFile);

    EVP_CIPHER_CTX_free(ctx);
    fclose(inputFile);
    fclose(outputFile);
}

void decryptFile(const char *inputFilename, const char *outputFilename, const char *keyFilename){
    FILE *inputFile = fopen(inputFilename, "rb");
    FILE *outputFile = fopen(outputFilename, "wb");
    FILE *keyFile = fopen(keyFilename, "rb");

    if (inputFile == NULL || outputFile == NULL || keyFile == NULL) {
        handleErrors();
    }

    unsigned char aes_key[AES_KEY_SIZE/8];
    fread(aes_key, sizeof(unsigned char), AES_KEY_SIZE/8, keyFile);
    fclose(keyFile);

    EVP_CIPHER_CTX *ctx;
    int len;
    unsigned char ciphertext[BUFFER_SIZE + EVP_MAX_BLOCK_LENGTH];
    unsigned char decryptedtext[BUFFER_SIZE];

    ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        handleErrors();
    }

    EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, aes_key, NULL);

    while ((len = fread(ciphertext, 1, BUFFER_SIZE + EVP_MAX_BLOCK_LENGTH, inputFile)) > 0) {
        if (EVP_DecryptUpdate(ctx, decryptedtext, &len, ciphertext, len) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            handleErrors();
        }
        fwrite(decryptedtext, 1, len, outputFile);
    }

    if (EVP_DecryptFinal_ex(ctx, decryptedtext, &len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        handleErrors();
    }

    fwrite(decryptedtext, 1, len, outputFile);

    EVP_CIPHER_CTX_free(ctx);
    fclose(inputFile);
    fclose(outputFile);
}


int main()
{
    generateAESKey("aes_key");
    encryptFile("input.txt", "encrypted_output.txt", "aes_key");
    decryptFile("encrypted_output.txt", "decrypted_output.txt", "aes_key");

    printf("Encryption successful.\n");

    return 0;
}