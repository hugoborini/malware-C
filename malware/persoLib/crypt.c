#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/rand.h>
#include <openssl/evp.h>


#define AES_KEY_SIZE 256
#define BUFFER_SIZE 1024

void handleErrors(void)
{
    perror("Error");
    exit(EXIT_FAILURE);
}


int generateAESKey(const char *filename) {
    FILE *keyFile = fopen(filename, "wb");
    if (keyFile == NULL) {
        printf("error");
        return 42;
    }

    unsigned char aes_key[AES_KEY_SIZE/8];
    if (!RAND_bytes(aes_key, sizeof(aes_key))) {
        printf("error");
        return 42;
    }

    fwrite(aes_key, sizeof(unsigned char), sizeof(aes_key), keyFile);
    fclose(keyFile);
    return 0;
}

int encryptFile(const char *inputFilename, const char *outputFilename, const char *keyFilename){
    FILE *inputFile = fopen(inputFilename, "rb");
    FILE *outputFile = fopen(outputFilename, "wb");
    FILE *keyFile = fopen(keyFilename, "rb");

    if (inputFile == NULL || outputFile == NULL || keyFile == NULL) {
        printf("error");
        return 42;
    }

    unsigned char aes_key[AES_KEY_SIZE/8];
    fread(aes_key, sizeof(unsigned char), AES_KEY_SIZE/8, keyFile);
    fclose(keyFile);

    EVP_CIPHER_CTX *ctx;
    int len;
    unsigned char plaintext[BUFFER_SIZE];
    unsigned char ciphertext[BUFFER_SIZE + EVP_MAX_BLOCK_LENGTH];

    ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        printf("error");
        return 42;
    }

    EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, aes_key, NULL);

    while ((len = fread(plaintext, 1, BUFFER_SIZE, inputFile)) > 0) {
        if (EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, len) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            printf("error");
            return 42;
        }
        fwrite(ciphertext, 1, len, outputFile);
    }

    if (EVP_EncryptFinal_ex(ctx, ciphertext, &len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        printf("error");
        return 42;
    }

    fwrite(ciphertext, 1, len, outputFile);

    EVP_CIPHER_CTX_free(ctx);
    fclose(inputFile);
    fclose(outputFile);

    return 0;
}

void decryptFile(const char *inputFilename, const char *outputFilename, const char *keyFilename){
    FILE *inputFile = fopen(inputFilename, "rb");
    FILE *outputFile = fopen(outputFilename, "wb");
    FILE *keyFile = fopen(keyFilename, "rb");

    if (inputFile == NULL || outputFile == NULL || keyFile == NULL) {
        handleErrors();
    }

    unsigned char aes_key[AES_KEY_SIZE/8];
    fread(aes_key, sizeof(unsigned char), AES_KEY_SIZE/8, keyFile);
    fclose(keyFile);

    EVP_CIPHER_CTX *ctx;
    int len;
    unsigned char ciphertext[BUFFER_SIZE + EVP_MAX_BLOCK_LENGTH];
    unsigned char decryptedtext[BUFFER_SIZE];

    ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        handleErrors();
    }

    EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, aes_key, NULL);

    while ((len = fread(ciphertext, 1, BUFFER_SIZE + EVP_MAX_BLOCK_LENGTH, inputFile)) > 0) {
        if (EVP_DecryptUpdate(ctx, decryptedtext, &len, ciphertext, len) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            handleErrors();
        }
        fwrite(decryptedtext, 1, len, outputFile);
    }

    if (EVP_DecryptFinal_ex(ctx, decryptedtext, &len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        handleErrors();
    }

    fwrite(decryptedtext, 1, len, outputFile);

    EVP_CIPHER_CTX_free(ctx);
    fclose(inputFile);
    fclose(outputFile);
}

char *appendFileName(char *prefix, char *src){
    int buffer = strlen(prefix) + strlen(src) + 1;
    char *final=malloc(sizeof(char) * buffer + 1);
    strcpy(final, prefix);
    strcat(final, src);

    

    return final;
}